#include <iostream>
#include <string.h>

using namespace std;

/*
/// http://blog.csdn.net/morewindows/article/details/7354571

符号 描述 运算规则

&    与   两个位都为1时，结果才为1
|    或   两个位都为0时，结果才为0
^    异或 两个位相同为0，相异为1
~    取反 0变1，1变0
<<   左移 各二进位全部左移若干位，高位丢弃，低位补0
>>   右移 各二进位全部右移若干位，对无符号数，高位补0，
          有符号数，各编译器处理方法不一样，有的补符号位（算术右移），
          有的补0（逻辑右移）

注意以下几点：

1. 在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。
2．位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。
3．对于移位操作，在微软的VC6.0和VS2008编译器都是采取算术称位即算术移位操作，
   算术移位是相对于逻辑移位，它们在左移操作中都一样，低位补0即可，
   但在右移中逻辑移位的高位补0而算术移位的高位是补符号位。如下面代码会输出-4和3。

int a = -15, b = 15;
printf("%d %d\n", a >> 2, b >> 2);

因为15=0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3。-15 = 1111 0001(二进制)，
右移二位，最高位由符号位填充将得到1111 1100即-4（见注1）。

4. 左移一位表示*2,右移一位表示/2。如 int a = 2 (0010); a << 1 = 4(0100) 同样，a / 2 == a >> 1。
5．位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。
   比如要得到像1，3，5，9这些2^i+1(次幂运算，不是异或)的数字。写成int a = 1 << i + 1;是不对的，程序会先执行i + 1，
   再执行左移操作。应该写成int a = (1 << i) + 1;
6．另外位操作还有一些复合操作符，如&=、|=、 ^=、<<=、>>=。
*/

/// 判断奇偶

/// 只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。
/// 因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。

void showOddInRange(int n)
{
    if (n)
    {
        cout << "Odd in [" << n <<"]: " << endl;
        for (int i = 0; i < n; ++i) {
            if ((i & 1) != 0)
                cout << i << " ";
        }
        cout << endl;
    }
}

/// 交换两数

void Swap(int &a, int &b)
{
    if (a != b)
    {
        a ^= b;
        b ^= a;
        a ^= b;
    }
}

/// 变换符号

/// 变换符号就是正数变成负数，负数变成正数。只需要取反后加1即可

int signChanged(int x)
{
    return ~x + 1;
}

/// 求绝对值

/*
位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。

对-6可以这样：1111 1010(二进制) C取反->0000 0101(二进制) -加1-> 0000 0110(二进制) 来得到6。

因此先移位来取符号位，int i = a >> 31;要注意如果a为正数，i等于0，为负数，i等于-1。
然后对i进行判断――如果i等于0，直接返回。否之，返回~a+1。
*/

int Abs(int x)
{
    int i = x >> 31;

    return i == 0 ? x : (~x + 1);
}

/// 高低位交换

/*
给出一个16位的无符号整数。称这个二进制数的前8位为“高位”，后8位为“低位”。

用二进制表示数:      34520 -> 10000110 11011000
将它的高低位进行交换:11011000 10000110 ->55430

将该数左移8位，然后和该数右移8位所得两个数相与。(x>>8) & (x<<8)
*/
template <class T>
void printBinary(T x)
{
    int i = 0;
    for (i = sizeof(x) * 8 - 1; i >= 0; --i)
    {
        if ((x >> i) & 1)
            cout << "1";
        else
            cout << "0";

        if (i % 8 == 0)
            cout << " ";
    }
    cout << endl;
}

template <class T>
T swapHighLowBits(T x)
{
    int mid = sizeof(T) * 8 / 2;
    //cout << "mid: " << mid << endl;
    return (x >> mid) | (x << mid);
}

///  二进制逆序

template <class T>
T reverseBinary(T x)
{
    T r = 0;

    int size = sizeof(x) * 8;

    for (int i = 0; i < size; ++i) // 0 ~ 31
    {
        r <<=1;
        r |= ((x >> i) & 0x1);
    }

    return r;
}



/// 二进制中1的个数

/// 求余法
/// 在将十进制数转换为二进制数时，采用除2取余法。将每次除2得到的余数保存起来逆序输出便是该十进制整数的二进制表示。

int BitCount1(int n)
{
    int sum = 0;
    while (n)
    {
        if ((n % 2) == 1)
            sum++;
        n /= 2;
    }
    return sum;
}

/// 位运算法
/// 每次先与0X01进行与操作，若非0，则计数器加1，然后向右移1位，循环这个过程。

int BitCount2(int n)
{
    int c = 0;
    while (n > 0)
    {
        if ((n & 0x1) == 1)
            ++c;
        n >>= 1;
    }

    return c;
}

/// 快速法 采用减1再进行与的运算，这样每进行一次，就会少一个1.
/// 比如: 0010 0110 减1得 0010 0101 & 0010 0110 等于 0010 0100.

int BitCount3(int n)
{
    int c = 0;

    for (c = 0; n; ++c)
    {
        n &= (n - 1);
    }
    return c;
}

/// 查表法 不同数据类型，表不同

int table[256]={
            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
            4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
            };

int BitCount4(unsigned char n)
{
    return table[n];
}

/// 缺失的数字, 只有一个数字出现一次，其他数字都出现两次

/// 利用异或运算的两个特性――1.自己与自己异或结果为0，2.异或满足交换律。
/// 因此我们将这些数字全异或一遍，结果就一定是那个仅出现一个的那个数。

int LostNumber(int *arr, int n)
{
    int lostNum = 0;
    for (int i = 0; i < n; ++i)
        lostNum ^= arr[i];

    return lostNum;
}

/// 数组中只出现1次的两个数字

/*
在一个数组中除两个数字只出现1次外，其它数字都出现了2次， 要求尽快找出这两个数字。

考虑下这个题目的简化版――数组中除一个数字只出现1次外，其它数字都成对出现，要求尽快找出这个数字。
根据异或运算的特点，直接异或一次就可以找出这个数字。

现在数组中有两个数字只出现1次，直接异或一次只能得到这两个数字的异或结果，
但光从这个结果肯定无法得到这个两个数字。因此我们来分析下简化版中“异或”解法的关键点，
这个关键点也相当明显――数组只能有一个数字出现1次。

设题目中这两个只出现1次的数字分别为A和B，如果能将A，B分开到二个数组中，那显然符合“异或”解法的关键点了。
因此这个题目的关键点就是将A，B分开到二个数组中。由于A，B肯定是不相等的，因此在二进制上必定有一位是不同的。
根据这一位是0还是1可以将A，B分开到A组和B组。而这个数组中其它数字要么就属于A组，要么就属于B组。
再对A组和B组分别执行“异或”解法就可以得到A，B了。
而要判断A，B在哪一位上不相同，只要根据A异或B的结果就可以知道了，这个结果在二进制上为1的位都说明A，B在这一位上是不相同的。

比如int a[] = {1, 1, 3, 5, 2, 2}

整个数组异或的结果为3^5即 0x0011 ^ 0x0101 = 0x0110
对0x0110，第1位（由低向高，从0开始）就是1。因此整个数组根据第1位是0还是1分成两组。

a[0] =1  0x00[0]1  第一组
a[1] =1  0x00[0]1  第一组
a[2] =3  0x00[1]1  第二组
a[3] =5  0x01[0]1  第一组
a[4] =2  0x00[1]0  第二组
a[5] =2  0x00[1]0  第二组

第一组有{1, 1, 5}，第二组有{3, 2, 3}，明显对这二组分别执行“异或”解法就可以得到5和3了。

*/

void FindTwoNotRepeatNumber(int *arr, int n, int *pN1, int *pN2)
{
    int i, temp;
    unsigned int j;

    // 计算这两个数的异或结果
    temp = 0;
    for (i = 0; i < n; ++i)
        temp ^= arr[i];

    // 找出第一个1的位
    for (j = 0; j < sizeof(int) * 8; ++j)
        if (((temp >> j) & 1) == 1)
            break;

    // 第j位为1,说明这两个数字在第j位上是不相同的
    // 由此分组即可
    *pN1 = 0, *pN2 = 0;
    for (i = 0; i < n; ++i)
        if (((arr[i] >> j) & 1) == 0)
            *pN1 ^= arr[i];
        else
            *pN2 ^= arr[i];
}


/// 数组中只出现一次的数

/* 数组A中，除了某一个数字x之外，其他数字都出现了三次，而x出现了一次。请给出最快的方法找到x。

前两篇文章是利用两个相同的数异或结果为0来计算的，但这个题目中其他数字是出现了3次，因此肯定不可以再使用异或了。
我们换一个角度来看，如果数组中没有x，那么数组中所有的数字都出现了3次，
在二进制上，每位上1的个数肯定也能被3整除。如{1, 5, 1, 5, 1, 5}从二进制上看有：

1：0001
5：0101
1：0001
5：0101
1：0001
5：0101

二进制第0位上有6个1，第2位上有3个1.第1位和第3位上都是0个1，每一位上的统计结果都可以被3整除。
而再对该数组添加任何一个数，如果这个数在二进制的某位上为1都将导致该位上1的个数不能被3整除。
因此通过统计二进制上每位1的个数就可以推断出x在该位置上是0还是1了，这样就能计算出x了。

推广一下，所有其他数字出现N（N>=2）次，而一个数字出现1次都可以用这种解法来推导出这个出现1次的数字。

*/

int FindNumber(int *arr, int n)
{
    int bits[32];
    int i, j;

    // 累加数组中所有数字的二进制位
    memset(bits, 0, 32 * sizeof(int));

    for (i = 0; i < n; ++i)
        for (j = 0; j < 32; ++j)
            bits[j] += ((arr[i] >> j) & 1);

    // 如果某位上的结果不能被整除，则肯定目标数字在这一位上为1
    int r = 0;
    for (j = 0; j < 32; ++j)
        if (bits[j] % 3 != 0)
            r += (1 << j);

    return r;
}

int main()
{
    /// 输出0到100之间的所有奇数
    showOddInRange(100);

    /// 交换两数
    int a = 1, b = 2;
    Swap(a, b);
    cout << "After swap: a=" << a << ", b=" << b << endl;

    int plus = 11, minus = -11;
    /// 1111 0101(二进制) 取反-> 0000 1010(二进制) 加1-> 0000 1011(二进制)
    cout << "signChanged(11): " << signChanged(plus) << endl;
    /// 0000 1011(二进制) 取反-> 1111 0100(二进制) 加1-> 1111 0101(二进制)
    cout << "signChanged(-11): " << signChanged(minus) << endl;

    unsigned short x = 34520;
    printBinary(x);

    unsigned short s = 12345;
    cout << "Before swapHighLowBits(12345): ";
    printBinary(s);

    unsigned short ss = swapHighLowBits(s);
    cout << "After swapHighLowBits(" << ss << "): ";
    printBinary(ss);

    unsigned short j = 34520;
    cout << "reverse(34520): 10000110 11011000 -> 00011011 01100001" << endl;
    unsigned short k = reverseBinary(j);
    cout << k << ": "; printBinary(k);

    short n = 12345;
    cout << "BitCount1(12345): " << BitCount1(n) << endl;
    cout << "BitCount2(12345): " << BitCount2(n) << endl;
    cout << "BitCount3(34520): " << BitCount3(n) << endl;
    unsigned char c = 128;
    cout << "BitCount3(128): " << BitCount4(c) << endl;

    int arr[15] = {1, 347, 6, 9, 13, 65, 889, 712, 889, 347, 1, 9, 65, 13, 712};
    cout << "Lost Number in a: " << LostNumber(arr, 15) << endl;

    int arr1[10] = {1, 2, 3, 4, 1,  2, 3, 4, 0, 5};
    cout << "array: ";
    for (int i = 0; i < 10; ++i)
        cout << arr1[i] << " ";
    cout << endl;

    int NoRep1, NoRep2;
    FindTwoNotRepeatNumber(arr1, 10, &NoRep1, &NoRep2);
    cout << "Not Repeated Numbers are: " << NoRep1 << " and " << NoRep2 << endl;

    int arr2[10] = {2, 3, 1, 2, 3, 4, 1, 2, 3, 1};
    cout << "array2: ";
    for (int i = 0; i < 10; ++i)
        cout << arr2[i] << " ";
    cout << endl;
    cout << "Find number not be 3 times: " << FindNumber(arr2, 10) << endl;

    return 0;
}
